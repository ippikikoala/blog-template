---
title: "【AUTOSAR】Adaptive Platform Specification – Communication Management (ara::com)のメモ"
date: "2025-04-27"
description: "7.1 - サービスインターフェースのバージョン管理として設計フェーズとDeployフェーズの２段階に分けて考えている - 設計フェーズではサービスインターフェースにメジャーバージョンとマイナーバージョンを持たせる - 後方互換"
category: ""
tags: []
image: ""
---

7.1

- サービスインターフェースのバージョン管理として設計フェーズとDeployフェーズの２段階に分けて考えている

- 設計フェーズではサービスインターフェースにメジャーバージョンとマイナーバージョンを持たせる

- 後方互換性のある（Eventの追加など）はマイナーバージョンの変更で対応。後方互換性のない場合は、メジャーバージョンを変更する

→メジャーバージョンの異なるIFはServiceDiscoveryが成立しない



- ServiceInterfaceをServiceInterfaceDeploymentで実際の通信仕様にマッピングする

- バージョン違いのServiceInterfaceを複数デプロイすることが可能

※デプロイメントは外部通信の場合は必須。IPC通信など内部通信には必須ではない

#### 7.2 Raw Data Streaming

- ara::comのAPIを利用しつつ、SOMEIPを使わずに通信したい場合に使用する

- 例えば非AUTOSARとの通信に使用する場合に使う

- RawDataStreamインスタンスを作成すると、ソケットを生成して通信してくれる。各種設定はManifestに書くべし

※あまり馴染みがないので一旦飛ばす

#### 7.3 Communication Group

こちらもあまり馴染みはないが…

- CGは一つのサーバと複数クライアントを持つ

- CGでサーバはブロードキャストとP2P通信が可能

- クライアントは通知に対してACKを返せる

- サーバはlistClients()を叩くことで、戻り値に接続しているClientIDで現在接続しているクライアントの一覧を得る

- ユニキャストもできる

Eventと何が違うの？と思ったが、

- App層からサーバに対して明示的にACKを返せる（Method FFを使うこともできそうだが…）

- サーバが接続されているクライアントを確認できる（Eventは送りっぱなし）



- 各種通信方式として

- broadcast()

- message()

→どちらも非同期関数（ara::core::Future）

- response：クライアントからの応答を通知。ClientIDと応答メッセージが含まれる

- CGの場合もClientとServerの接続はOffer, Find Serviceを使用

#### 7.5 Network Binding

- Network BindingとはIFをデプロイ時に使う通信プロトコルに紐づけること

- 設定はDeployment Manifestで実行

→APIを色々な方法でデプロイすることが可能に

以下を設定できる

- SOMEIPのL4のプロトコル（UDP・TCP）

- ポート番号

- マルチキャストアドレス（UDPの場合）

#### 7.6 SOME/IP Binding

- ara::com APIとSOMEIPのバインディングについて説明

- アプリ実装者はara::com APIを使用するだけでSOMEIP通信ができる（できるらしいよ）

- SOMEIP-SDで動的にサービスを見つけることができる

- SOME/IPの通信形式として

- Method（確実性の観点からTCPを使うことが多い）

- Event（効率性の観点からマルチキャスト、UDPを使うことが多い）

- Field

- SOME/IPのデプロイメント設定（manifest.xml） で以下（など）を定義

- 通信に使うポート番号

- L4のプロトコル（UDPかTCP）

- マルチキャストアドレス

- TTLや再送設定

- SOME/IP通信中に起きたエラー（接続断、受信失敗など）は、ara::com API を通じてアプリケーションに通知

- ara::comのAPIがエラーを返すのでアプリはそれを適切にハンドリングする必要あり

- ID体系として

- ServiceID：サービスを特定

- InstanceID：同じサービスを複数提供するときの識別子

- MethodID

- EventID

- EventのSubscribe

- ara::com APIのSubscribe()を呼び出すと、SOME/IP-SDのSubscribeEventGroup メッセージがサーバに飛ぶ

- クライアントは定期的にSubscribeを送信する。TTLが設定されており、TTLが切れていればEventは通知されない

- サーバから送信されるSubscribeACKにもTTLが含まれるので、サーバのTTL＜クライアントのTTLの場合はサーバのTTLに制限される

- Unsubscribe()を呼び出すとStopSubscribeEventGroupメッセージがサーバに飛ぶ

- 通信エラーのハンドリングについて

- タイムアウトや接続不良（TCPのコネクションが切れるなど）等のエラーに対して、リトライや縮退など適切なハンドリングをアプリは実装する必要がある

→複数回サーバから返信が来なかったら縮退に入ってユーザに伝えるなど

#### 7.7 IPC Binding

- １つのECU内の通信

- SOMEIPのようなネットワークスタックは使わず、より効率的な通信手段を使う

- IPC Bindingではシリアライズなどネットワーク通信に必要な家庭を避けることができる

- アプリコードはIPC通信であってもそうでなくても記載は変わらない

- どの通信形式を使うかはDeploymentManifestで定義する

- IPC Bindingの内部実像はベンダーによって変わる（共有メモリ、ローカルソケットなど）

- 同じサービスがIPCでも外部ネットワークを使う場合でも動的に最適な経路を選択してくれる

- Manifestでどちらかを選択することもできる





【気になったこと】

・同じara::com APIを叩けばIPCでも外部通信でも同じように通信できる

・けれども、IPCの場合にSubscribeのTTLのようなものは存在しないらしい

・成否はSubscribe()の戻り値で管理される



IPC、外部通信の実装の仕様を見ないとだなあ
